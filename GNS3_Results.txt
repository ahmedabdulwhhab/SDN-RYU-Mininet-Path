Adding VMware VMs to GNS3 Topologies
https://docs.gns3.com/docs/emulators/adding-vmware-vms-to-gns3-topologies/



openvswitch management
https://www.gns3.com/marketplace/appliances/open-vswitch-with-management-interface


Docker 
https://www.gns3.com/marketplace/appliances/ubuntu



ovs-vsctl set bridge br0 protocols=OpenFlow13
 ovs-vsctl set-controller br0 tcp:192.168.122.163:6633
 ovs-ofctl -O OpenFlow13 dump-flows br0



ovs-vsctl get-controller br0


 ovs-vsctl set bridge br0 protocols=OpenFlow13

ovs-vsctl set-fail-mode br0 standalone


sudo apt install telnet

ovs-vsctl set-fail-mode br0 secure  ---------------> openflow only


----------------------------
#layer 4 APP.py
#################################
"""
 sudo mn -c; sudo mn --controller=remote,ip=127.0.0.1:6633 --mac --switch=ovsk,protocols=OpenFlow13 --topo=linear,3,4

 h4s3 timeout 20s hping3 -S -V -d 120 -w 64 -p 80 --rand-source --flood 10.0.0.1
 
 
 
Start IPERF Server in h3s3
h3s3 iperf -s &
Start the IPERF Client in h1 and connecting to h4
h1s1 iperf -c h3s3
Analyze the results by flows
sudo ovs-ofctl -O OpenFlow13 dump-flows s1
we observe traffic in both directions.

h1 to h4 traffc is very high (in Gbps). This is data traffic. h4 to h1 traffic is very less. This is TCP Acknowledge traffic.

Analyze the results by ports.
sudo ovs-ofctl -O OpenFlow13 dump-ports s1
h1 --------port1, port4--------h4

Forward traffic:

h1 transimits. port1 receives.
port4 transmits, h4 receives.
Acknowlege:

h4 transmits. port4 receives.
port1 transmits. h1 receives.
#### B. Bidirectional Traffic test h1 to h4(sequentially).

Start IPERF Server in h4
h4 iperf -s &
Start the IPERF Client in h1 and connecting to h4
Copy
h1 iperf -c h4 -r 
Start IPERF Server in h4
h4 iperf -s &
Start the IPERF Client in h1 and connecting to h4
h1 iperf -c h4 -d
Its parallel test , both direction h1 to h4 as well h4 to h1 traffic tests started.

#### D. Traffic test from h1 to h4 with Multiple Sessions.

Start IPERF Server in h4
h4 iperf -s &
Start the IPERF Client in h1 and connecting to h4
Copy
h1 iperf -c h4 -P 5


Multiple Parallel calls VOIP calls test
1) Run the IPERF UDP server in h4

mininet>h1s1 iperf --server --udp --len 300 --tos 184 -fk --interval 5 --parallel 4
2) Run the IPERF UDP Client in h1

Copy
mininet>h2s2 iperf -c 10.1.1.4 --udp --len 300 --bandwidth 67000 --dualtest --tradeoff --tos 184 -fk --interval 5 --time 60 --listenport 5002 --parallel 4
#References
"""

from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet
from ryu.lib.packet import arp
from ryu.lib.packet import ethernet
from ryu.lib.packet import ether_types

from ryu.lib.packet import in_proto
from ryu.lib.packet import ipv4
from ryu.lib.packet import icmp
from ryu.lib.packet import tcp
from ryu.lib.packet import udp

FLOW_SERIAL_NO = 0

def get_flow_number():
    global FLOW_SERIAL_NO
    FLOW_SERIAL_NO = FLOW_SERIAL_NO + 1
    return FLOW_SERIAL_NO


class SimpleSwitch13(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(SimpleSwitch13, self).__init__(*args, **kwargs)
        self.mac_to_port = {}
        self.mitigation = 0
        self.arp_ip_to_port = {}

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        
        flow_serial_no = get_flow_number()

        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,
                                          ofproto.OFPCML_NO_BUFFER)]
        self.add_flow(datapath, 0, match, actions, flow_serial_no)

    def add_flow(self, datapath, priority, match, actions, serial_no, buffer_id=None, idle=0, hard=0):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser

        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,
                                             actions)]
        if buffer_id:
            mod = parser.OFPFlowMod(datapath=datapath, cookie=serial_no, buffer_id=buffer_id,
                                    idle_timeout=idle, hard_timeout=hard,
                                    priority=priority, match=match,
                                    instructions=inst)
        else:
            mod = parser.OFPFlowMod(datapath=datapath, cookie=serial_no, priority=priority,
                                    idle_timeout=idle, hard_timeout=hard,
                                    match=match, instructions=inst)
            
        datapath.send_msg(mod)

    def block_port(self, datapath, portnumber,src):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        match = parser.OFPMatch(in_port=portnumber,eth_src=src)
        actions = []
        flow_serial_no = get_flow_number()
        
        self.add_flow(datapath, 100, match, actions, flow_serial_no, hard=240)

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def _packet_in_handler(self, ev):
        if ev.msg.msg_len < ev.msg.total_len:
            self.logger.debug("packet truncated: only %s of %s bytes",
                              ev.msg.msg_len, ev.msg.total_len)
        msg = ev.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']

        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocols(ethernet.ethernet)[0]

        if eth.ethertype == ether_types.ETH_TYPE_LLDP:
            return
        dst = eth.dst
        src = eth.src

        dpid = datapath.id
        self.mac_to_port.setdefault(dpid, {})
        self.arp_ip_to_port.setdefault(dpid, {})
        self.arp_ip_to_port[dpid].setdefault(in_port, [])

        # learn a mac address to avoid FLOOD next time.
        self.mac_to_port[dpid][src] = in_port

        if dst in self.mac_to_port[dpid]:
            out_port = self.mac_to_port[dpid][dst]
        else:
            out_port = ofproto.OFPP_FLOOD

        actions = [parser.OFPActionOutput(out_port)]
        #if ARP Request packet , log the IP and MAC Address from that port
        if eth.ethertype == ether_types.ETH_TYPE_ARP:
            #self.logger.info("Received ARP Packet %s %s %s ", dpid, src, dst)
            a = pkt.get_protocol(arp.arp)
            #print "arp packet ", a
            if a.opcode == arp.ARP_REQUEST or a.opcode == arp.ARP_REPLY:
                if not a.src_ip in self.arp_ip_to_port[dpid][in_port]:
                    self.arp_ip_to_port[dpid][in_port].append(a.src_ip)

        # install a flow to avoid packet_in next time
        if out_port != ofproto.OFPP_FLOOD:

            # check IP Protocol and create a match for IP
            if eth.ethertype == ether_types.ETH_TYPE_IP:
                ip = pkt.get_protocol(ipv4.ipv4)
                srcip = ip.src
                dstip = ip.dst
                protocol = ip.proto

            # check IP Protocol and create a match for IP
            if eth.ethertype == ether_types.ETH_TYPE_IP:
                ip = pkt.get_protocol(ipv4.ipv4)
                srcip = ip.src
                dstip = ip.dst
                protocol = ip.proto

                # if ICMP Protocol
                if protocol == in_proto.IPPROTO_ICMP:
                    t = pkt.get_protocol(icmp.icmp)
                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, eth_dst=dst, eth_src=src,
                                            ipv4_src=srcip, ipv4_dst=dstip,in_port=in_port,
                                            ip_proto=protocol,icmpv4_code=t.code,
                                            icmpv4_type=t.type)

                 #  if TCP Protocol
                elif protocol == in_proto.IPPROTO_TCP:
                    t = pkt.get_protocol(tcp.tcp)
                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, eth_dst=dst, eth_src=src,
                                            ipv4_src=srcip, ipv4_dst=dstip,
                                            ip_proto=protocol,in_port=in_port,
                                            tcp_src=t.src_port, tcp_dst=t.dst_port,)

                #  If UDP Protocol
                elif protocol == in_proto.IPPROTO_UDP:
                    u = pkt.get_protocol(udp.udp)
                    match = parser.OFPMatch(eth_type=ether_types.ETH_TYPE_IP, eth_dst=dst, eth_src=src,
                                            ipv4_src=srcip, ipv4_dst=dstip,
                                            ip_proto=protocol,in_port=in_port,
                                            udp_src=u.src_port, udp_dst=u.dst_port,)
                #print("mitigation")
                if self.mitigation:
                    #print("mitigation_in")
                    if not (srcip in self.arp_ip_to_port[dpid][in_port]):
                        print("attack detected from port ", in_port)
                        print("Block the port ", in_port," at datapath ", datapath.id, " src mac ",src)
                        self.block_port(datapath, in_port,src)
                        #print ip
                        #self.mitigation = 0
                        return

                # verify if we have a valid buffer_id, if yes avoid to send both
                # flow_mod & packet_out
                flow_serial_no = get_flow_number()

                if msg.buffer_id != ofproto.OFP_NO_BUFFER:
                    self.add_flow(datapath, 10, match, actions, flow_serial_no, msg.buffer_id, idle=100, hard=200)
                    return
                else:
                    self.add_flow(datapath, 10, match, actions, flow_serial_no, idle=100, hard=200)
        data = None
        if msg.buffer_id == ofproto.OFP_NO_BUFFER:
            data = msg.data

        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                  in_port=in_port, actions=actions, data=data)
        datapath.send_msg(out)



-------------------------------
#sudo ryu-manager  app1.py --observe-links --ofp-tcp-listen-port 6653
-------------------------------
/ #  ovs-ofctl -O OpenFlow13 dump-flows br0
 cookie=0x2, duration=8.465s, table=0, n_packets=9, n_bytes=882, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth0,dl_src=52:54:00:24:14:53,dl_dst=ca:c5:5a:7d:6c:5e,nw_src=142.250.200.228,nw_dst=192.168.122.203,icmp_type=0,icmp_code=0 actions=output:eth0
 cookie=0x4, duration=7.525s, table=0, n_packets=8, n_bytes=784, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth0,dl_src=ca:c5:5a:7d:6c:5e,dl_dst=52:54:00:24:14:53,nw_src=192.168.122.203,nw_dst=142.250.200.228,icmp_type=8,icmp_code=0 actions=output:eth0
 cookie=0x5, duration=6.769s, table=0, n_packets=6, n_bytes=588, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth1,dl_src=00:50:79:66:68:00,dl_dst=00:50:79:66:68:01,nw_src=10.0.0.1,nw_dst=10.0.0.2,icmp_type=8,icmp_code=0 actions=output:eth2
 cookie=0x3, duration=7.823s, table=0, n_packets=7, n_bytes=686, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth2,dl_src=00:50:79:66:68:01,dl_dst=00:50:79:66:68:00,nw_src=10.0.0.2,nw_dst=10.0.0.1,icmp_type=0,icmp_code=0 actions=output:eth1
 cookie=0x1, duration=9.220s, table=0, n_packets=9, n_bytes=652, priority=0 actions=CONTROLLER:65535


-----------------------------------------------------------------------------
OVS Putty after adding Block for mitigation
OpenvSwitch-1 console is now available... Press RETURN to get started.
udhcpc (v1.24.2) started
Sending discover...
Sending discover...
Sending discover...
Sending discover...
Sending discover...
udhcpc failed to get a DHCP lease
No lease, forking to background
2023-06-10T02:57:14Z|00001|ovs_numa|INFO|Discovered 1 CPU cores on NUMA node 0
2023-06-10T02:57:14Z|00002|ovs_numa|INFO|Discovered 1 NUMA nodes and 1 CPU cores
2023-06-10T02:57:14Z|00003|reconnect|INFO|unix:/var/run/openvswitch/db.sock: connecting...
2023-06-10T02:57:14Z|00004|reconnect|INFO|unix:/var/run/openvswitch/db.sock: connected
2023-06-10T02:57:14Z|00005|pmd_perf|INFO|Estimated TSC frequency: 2305463 KHz
2023-06-10T02:57:14Z|00006|dpif_netdev_extract|INFO|Default MFEX Extract implementation is scalar.
2023-06-10T02:57:14Z|00007|dpif_netdev_impl|INFO|Default DPIF implementation is dpif_scalar.
2023-06-10T02:57:14Z|00008|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports recirculation
2023-06-10T02:57:14Z|00009|ofproto_dpif|INFO|netdev@ovs-netdev: VLAN header stack length probed as 1
2023-06-10T02:57:14Z|00010|ofproto_dpif|INFO|netdev@ovs-netdev: MPLS label stack length probed as 3
2023-06-10T02:57:14Z|00011|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports truncate action
2023-06-10T02:57:14Z|00012|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports unique flow ids
2023-06-10T02:57:14Z|00013|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports clone action
2023-06-10T02:57:14Z|00014|ofproto_dpif|INFO|netdev@ovs-netdev: Max sample nesting level probed as 10
2023-06-10T02:57:14Z|00015|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports eventmask in conntrack action
2023-06-10T02:57:14Z|00016|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_clear action
2023-06-10T02:57:14Z|00017|ofproto_dpif|INFO|netdev@ovs-netdev: Max dp_hash algorithm probed to be 1
2023-06-10T02:57:14Z|00018|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports check_pkt_len action
2023-06-10T02:57:14Z|00019|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports timeout policy in conntrack action
2023-06-10T02:57:14Z|00020|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_zero_snat
2023-06-10T02:57:14Z|00021|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports add_mpls action
2023-06-10T02:57:14Z|00022|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_state
2023-06-10T02:57:14Z|00023|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_zone
2023-06-10T02:57:14Z|00024|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_mark
2023-06-10T02:57:14Z|00025|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_label
2023-06-10T02:57:14Z|00026|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_state_nat
2023-06-10T02:57:14Z|00027|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_orig_tuple
2023-06-10T02:57:14Z|00028|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports ct_orig_tuple6
2023-06-10T02:57:14Z|00029|ofproto_dpif|INFO|netdev@ovs-netdev: Datapath supports IPv6 ND Extensions
2023-06-10T02:57:14Z|00030|ofproto_dpif_upcall|INFO|Setting n-handler-threads to 1, setting n-revalidator-threads to 1
2023-06-10T02:57:14Z|00031|ofproto_dpif_upcall|INFO|Starting 2 threads
2023-06-10T02:57:14Z|00032|dpif_netdev|INFO|pmd-rxq-affinity isolates PMD core
2023-06-10T02:57:14Z|00033|dpif_netdev|INFO|PMD auto load balance interval set to 1 mins
2023-06-10T02:57:14Z|00034|dpif_netdev|INFO|PMD auto load balance improvement threshold set to 25%
2023-06-10T02:57:14Z|00035|dpif_netdev|INFO|PMD auto load balance load threshold set to 95%
2023-06-10T02:57:14Z|00036|dpif_netdev|INFO|PMD auto load balance is disabled.
2023-06-10T02:57:14Z|00037|bridge|INFO|bridge br3: added interface br3 on port 65534
2023-06-10T02:57:14Z|00038|bridge|INFO|bridge br0: added interface eth11 on port 12
2023-06-10T02:57:14Z|00039|bridge|INFO|bridge br0: added interface eth8 on port 9
2023-06-10T02:57:14Z|00040|bridge|INFO|bridge br0: added interface eth4 on port 5
2023-06-10T02:57:14Z|00041|bridge|INFO|bridge br0: added interface eth10 on port 11
2023-06-10T02:57:14Z|00042|bridge|INFO|bridge br0: added interface eth9 on port 10
2023-06-10T02:57:14Z|00043|bridge|INFO|bridge br0: added interface eth7 on port 8
2023-06-10T02:57:14Z|00044|bridge|INFO|bridge br0: added interface eth0 on port 1
2023-06-10T02:57:14Z|00045|bridge|INFO|bridge br0: added interface eth13 on port 14
2023-06-10T02:57:14Z|00046|bridge|INFO|bridge br0: added interface eth5 on port 6
2023-06-10T02:57:14Z|00047|bridge|INFO|bridge br0: added interface eth3 on port 4
2023-06-10T02:57:14Z|00048|bridge|INFO|bridge br0: added interface eth1 on port 2
2023-06-10T02:57:14Z|00049|bridge|INFO|bridge br0: added interface eth6 on port 7
2023-06-10T02:57:14Z|00050|bridge|INFO|bridge br0: added interface eth12 on port 13
2023-06-10T02:57:14Z|00051|bridge|INFO|bridge br0: added interface br0 on port 65534
2023-06-10T02:57:14Z|00052|bridge|INFO|bridge br0: added interface eth2 on port 3
2023-06-10T02:57:14Z|00053|bridge|INFO|bridge br0: added interface eth14 on port 15
2023-06-10T02:57:14Z|00054|bridge|INFO|bridge br0: added interface eth15 on port 16
2023-06-10T02:57:14Z|00055|bridge|INFO|bridge br2: added interface br2 on port 65534
2023-06-10T02:57:14Z|00056|bridge|INFO|bridge br1: added interface br1 on port 65534
2023-06-10T02:57:14Z|00057|bridge|INFO|bridge br3: using datapath ID 00004e24c729f445
2023-06-10T02:57:14Z|00058|connmgr|INFO|br3: added service controller "punix:/var/run/openvswitch/br3.mgmt"
2023-06-10T02:57:14Z|00059|bridge|INFO|bridge br0: using datapath ID 00004efa7122cd4f
2023-06-10T02:57:14Z|00060|connmgr|INFO|br0: added service controller "punix:/var/run/openvswitch/br0.mgmt"
2023-06-10T02:57:14Z|00061|rconn|INFO|br0<->tcp:192.168.122.163:6633: connecting...
2023-06-10T02:57:14Z|00062|connmgr|INFO|br0: added primary controller "tcp:192.168.122.163:6633"
2023-06-10T02:57:14Z|00063|bridge|INFO|bridge br2: using datapath ID 0000ea340e18854f
2023-06-10T02:57:14Z|00064|connmgr|INFO|br2: added service controller "punix:/var/run/openvswitch/br2.mgmt"
2023-06-10T02:57:14Z|00065|bridge|INFO|bridge br1: using datapath ID 0000866e6641d74d
2023-06-10T02:57:14Z|00066|connmgr|INFO|br1: added service controller "punix:/var/run/openvswitch/br1.mgmt"
/ # ovs-vsctl set bridge br0 protocols=OpenFlow13
/ # ovs-vsctl set-controller br0 tcp:192.168.122.163:6633
/ # ovs-vsctl set-fail-mode br0 secure
/ #  ovs-ofctl -O OpenFlow13 dump-flows br0
 cookie=0x4, duration=16.673s, table=0, n_packets=6, n_bytes=470, hard_timeout=240, priority=100,in_port=eth0,dl_src=00:0c:29:33:0b:24 actions=drop
 cookie=0x5, duration=16.672s, table=0, n_packets=6, n_bytes=438, hard_timeout=240, priority=100,in_port=eth0,dl_src=52:54:00:24:14:53 actions=drop
 cookie=0x1, duration=68.706s, table=0, n_packets=62, n_bytes=3832, priority=0 actions=CONTROLLER:65535
/ #  ovs-ofctl -O OpenFlow13 dump-flows br0
 cookie=0x4, duration=21.542s, table=0, n_packets=11, n_bytes=840, hard_timeout=240, priority=100,in_port=eth0,dl_src=00:0c:29:33:0b:24 actions=drop
 cookie=0x5, duration=21.541s, table=0, n_packets=9, n_bytes=678, hard_timeout=240, priority=100,in_port=eth0,dl_src=52:54:00:24:14:53 actions=drop
 cookie=0x1, duration=73.575s, table=0, n_packets=64, n_bytes=3936, priority=0 actions=CONTROLLER:65535
/ #





############################## after ping 10.0.0.1
/ #  ovs-ofctl -O OpenFlow13 dump-flows br0
 cookie=0x4, duration=151.991s, table=0, n_packets=67, n_bytes=5504, hard_timeout=240, priority=100,in_port=eth0,dl_src=00:0c:29:33:0b:24 actions=drop
 cookie=0x5, duration=151.990s, table=0, n_packets=49, n_bytes=4142, hard_timeout=240, priority=100,in_port=eth0,dl_src=52:54:00:24:14:53 actions=drop
 cookie=0x6, duration=27.037s, table=0, n_packets=20, n_bytes=1960, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth2,dl_src=00:50:79:66:68:01,dl_dst=00:50:79:66:68:00,nw_src=10.0.0.2,nw_dst=10.0.0.1,icmp_type=8,icmp_code=0 actions=output:eth1
 cookie=0x7, duration=27.029s, table=0, n_packets=20, n_bytes=1960, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth1,dl_src=00:50:79:66:68:00,dl_dst=00:50:79:66:68:01,nw_src=10.0.0.1,nw_dst=10.0.0.2,icmp_type=0,icmp_code=0 actions=output:eth2
 cookie=0x1, duration=204.024s, table=0, n_packets=139, n_bytes=8024, priority=0 actions=CONTROLLER:65535



######################## after ping 10.0.0.2
/ #  ovs-ofctl -O OpenFlow13 dump-flows br0
 cookie=0x8, duration=43.457s, table=0, n_packets=16, n_bytes=1248, hard_timeout=240, priority=100,in_port=eth0,dl_src=00:0c:29:33:0b:24 actions=drop
 cookie=0xb, duration=38.546s, table=0, n_packets=12, n_bytes=1158, hard_timeout=240, priority=100,in_port=eth0,dl_src=52:54:00:24:14:53 actions=drop
 cookie=0x6, duration=158.762s, table=0, n_packets=151, n_bytes=14798, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth2,dl_src=00:50:79:66:68:01,dl_dst=00:50:79:66:68:00,nw_src=10.0.0.2,nw_dst=10.0.0.1,icmp_type=8,icmp_code=0 actions=output:eth1
 cookie=0x7, duration=158.754s, table=0, n_packets=151, n_bytes=14798, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth1,dl_src=00:50:79:66:68:00,dl_dst=00:50:79:66:68:01,nw_src=10.0.0.1,nw_dst=10.0.0.2,icmp_type=0,icmp_code=0 actions=output:eth2
 cookie=0xc, duration=8.732s, table=0, n_packets=4, n_bytes=392, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth1,dl_src=00:50:79:66:68:00,dl_dst=00:50:79:66:68:01,nw_src=10.0.0.1,nw_dst=10.0.0.2,icmp_type=8,icmp_code=0 actions=output:eth2
 cookie=0xd, duration=8.723s, table=0, n_packets=4, n_bytes=392, idle_timeout=100, hard_timeout=200, priority=10,icmp,in_port=eth2,dl_src=00:50:79:66:68:01,dl_dst=00:50:79:66:68:00,nw_src=10.0.0.2,nw_dst=10.0.0.1,icmp_type=0,icmp_code=0 actions=output:eth1
 cookie=0x1, duration=335.749s, table=0, n_packets=209, n_bytes=11780, priority=0 actions=CONTROLLER:65535
